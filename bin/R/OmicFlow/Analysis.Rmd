---
title: "Data Analysis"
author: "RTC Bioinformatics"
date: "2024-03-18"
output: pdf_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE) 
```

## Required Library's

```{r, warning=FALSE}
library("Matrix")
library("ggplot2")
library("OmicFlow")
library("ggtree")
library("patchwork")
```

# Investigating HBS and BaCo on contamination
```{r}
taxa <- metataxonomics$new(metaData = "../../../Pathology/projects/HEREDITARY/data/metadata.tsv",
                               biomData = "../../../Pathology/projects/HEREDITARY/data/biom_with_taxonomy.biom",
                               treeData = "../../../Pathology/projects/HEREDITARY/data/rooted_tree.newick")
taxa$reset()

taxa$feature_subset(Domain == "Bacteria")
taxa$feature_glom(feature_rank = "Species")

pcoa <- taxa$ordination(metric = "bray", 
                method = "pcoa", 
                group_by = "study_group", 
                weighted = TRUE, 
                normalize = TRUE,
                parallel = TRUE,
                cpus = 4)


ggsave(filename = "../../../Pathology/projects/HEREDITARY/results/nmds_genus.png",
       plot = patchwork::wrap_plots(nmds$anova_plot, nmds$scores_plot),
       units = "cm",
       width = 20,
       height = 10,
       limitsize = FALSE,
       dpi = 400,
       scaling = 0.5)

taxa$alpha_diversity(col_name = "study_group", method = "shannon")

```
## PANEL
```{r}
main_panel_1 <- (wrap_elements(plt_1) + 
                   wrap_elements(plt_2) +
                   plot_layout(widths = c(5, 6))) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(face = 'bold', size = 15))

ggsave(filename = "../../../Pathology/projects/HEREDITARY/results/studygroups_composition.png",
       plot = main_panel_1,
       units = "cm",
       width = 20,
       height = 10,
       limitsize = FALSE,
       dpi = 400,
       scaling = 0.5)

```

# Improving countData with TsparseMatrix
```{r}
# TO DO:
  # Replace tools basic fread to sparse matrix load
  # Change methods accordingly:
    # rankstat [DONE]
    # alpha_diversity
      # - NOTE: vegan converts sparse to matrix, this will explode in computation time, find an alternative package
    # composition [DONE]
    # ordination [DONE] 
      # - NOTE: 137k features seems to be a limit
    # differential_feature_expression
    # correlation


large_dd <- metataxonomics$new(metaData = "../../../Pathology/projects/HEREDITARY/data/metadata.tsv",
                           biomData = "../../../Pathology/projects/HEREDITARY/data/biom_with_taxonomy.biom",
                           treeData = "../../../Pathology/projects/HEREDITARY/data/rooted_tree.newick")

large_dd$feature_subset(Domain == "Bacteria")


result <- large_dd$composition(feature_rank = "Genus",
                                 feature_filter = c("uncultured"),
                                 feature_top = 10)

composition_plot(data = result$data,
                 palette = result$palette,
                 feature_rank = "Genus")

large_dd$feature_glom(feature_rank = "Genus")

pcoa_plots <- large_dd$ordination(metric = "unifrac",
                                    method = "pcoa",
                                    group_by = "SAMPLE-ID", 
                                    weighted = TRUE,
                                    parallel = TRUE,
                                    normalize = TRUE)

```


## Specify data paths

## Constructing metataxonomics class
```{r, eval=FALSE}
taxa <- metataxonomics$new(metaData = "tests/testthat/input/metataxonomics/metadata.tsv",
                           biomData = "tests/testthat/input/metataxonomics/biom_with_taxonomy.biom",
                           treeData = "tests/testthat/input/metataxonomics/rooted_tree.newick")


taxa$feature_subset(Domain == "Bacteria")
taxa$normalize()
taxa$transform(log2)

shannon <- taxa$alpha_diversity(col_name = "BMI", method = "shannon")



result <- taxa$composition(feature_rank = "Genus",
                                 feature_filter = c("uncultured"),
                                 feature_top = 10)

composition_plot(data = result$data,
                 palette = result$palette,
                 feature_rank = "Genus")


```

# General analysis flow
## Rankstat
### Classified ASVs per taxonomic rank

```{r}
rankstat_plot <- taxa$rankstat()

```

## Proportion of classified ASVs per taxonomic rank for each sample

```{r}
taxa_class$feature_subset(Domain == "Bacteria")
result <- taxa_class$composition(feature_rank = "Genus",
                                 feature_filter = c("uncultured"),
                                 feature_top = 10)
taxa_class$reset()

composition_plot(data = result$data,
                 palette = result$palette,
                 feature_rank = "Genus")

```

## Alpha diversity 
### Shannon index graph: data from nextflow run
```{r}
df_shannon <- data.table::fread(paste0(current_path, "/data/shannon.csv"))

# Pivot into long table
shannon_long <- data.table::melt(data = df_shannon,
                                 measure.vars = colnames(df_shannon)[grepl("depth-", colnames(df_shannon))], 
                                 variable.name = "iters",
                                 variable.factor = FALSE,
                                 value.name = "alpha_div")
# Corrects colnames
colnames(shannon_long) <- c("SAMPLE-ID", "iters", "alpha_div")
# Adds new column
shannon_final <- base::merge(shannon_long, 
                             taxa$metaData[, .SD, .SDcols = c("SAMPLE-ID", col_name)], 
                             by = "SAMPLE-ID", 
                             all.x = TRUE)

taxa$shannon(custom_div = shannon_final)

taxa_class$feature_subset(Domain == "Bacteria")
shannon_plot <- taxa$shannon(df_shannon = df_shannon,
                                   col_name = "RANKSTAT_treatment")
taxa_class$reset()

```


## Principal Coordinate Analysis with Weighted Unifrac distances
```{r}
# normalized by bacterial domain
taxa_class$feature_subset(Domain == "Bacteria")
pcoa_plots <- taxa$ordination(metric = "unifrac",
                                    method = "pcoa",
                                    group_by = "SAMPLE-ID", 
                                    weighted = TRUE,
                                    parallel = TRUE,
                                    normalize = TRUE)
taxa_class$reset()

ggsave("results/pcoa_test.png",
       plot = comb_plot,
       width = 15,
       height = 5)

```

## TREE with extra layers
```{r}

feature_rank = "Genus"
feature_filter = c("uncultured")

cor_columns = c("BMI", "Weight")

taxa$correlation(feature_rank = "Genus",
                 feature_filter = c("uncultured"),
                 cor_method = "spearman",
                 cor_columns = c("BMI", "Weight"))

```

# Clustering methods
```{r}



```

# (stepwise) Regression models
```{r}
both_model <- lm(mpg ~ ., data=mtcars)

final_model <- step(both_model, 
                    direction="both", 
                    trace = 0)

# computing AIC and BIC for a model using:
stats::AIC()
stats::BIC()

# models
lm # linear regression
glm # logistic regression

# Detect multicollinearity factorrs with:
regclass:VIF()

null_model = lm(Fuel ~ 1, data=fuel2001_4)
full_model = lm(Fuel ~ Tax + Dlic + Income_2 + log_Miles + Tax:Dlic + Tax:Income_2 + Tax:log_Miles + Dlic:Income_2 + Dlic:log_Miles + Income_2:log_Miles + I(Tax^2) + I(Tax^3) + I(Tax^4) + I(Dlic^2) + I(Dlic^3) + I(Dlic^4) + I(Income_2^2) + I(Income_2^3) + I(Income_2^4) + I(log_Miles^2) + I(log_Miles^3) + I(log_Miles^4), data=fuel2001_4)

# step function
model_step = step(model, 
                  scope = list(lower=null_model, upper=full_model),
                  direction = "both", k= 2) 
                  # direction = c("both", "backward", "forward")
                  # k=2 for AIC; k=log(nrow(train_data)) for BIC


```


# Creating transcriptomics class
```{r}
#' Sub-class metataxonomics
#'
#' @description This is a sub-class for 16S metagenomics data, called metataxonomics.
#' It inherits all methods from the abstract class \link[OmicFlow]{tools} and only adapts the \code{initialize} function.
#'
#' @export

transcriptomics <- R6::R6Class(
  classname = "transcriptomics",
  cloneable = FALSE,
  inherit = tools,
  public = list(
    countData = NULL,
    featureData = NULL,
    metaData = NULL,
    scRNA = FALSE,

    #' @description
    #' Initializes the transcriptomics class object with \code{transcriptomics$new()}
    initialize = function(countData = NA, metaData = NA, featureData = NA, cells = NA) {
      # Checking what file format it is
      if (tools::file_ext(countData) == "gz") tmp_ext_file = sub(".gz", "", countData)
      else if (tools::file_ext(tmp_ext_file) == "mtx") {
        # Reading matrix and converts to data.table
        self$countData <- Matrix::readMM(countData)

      } else if (self$scRNA) {
        self$featureData <- data.table::fread(featureData)
        cellsData <- data.table::data.table(cells)
        dimnames(self$countData) <- list(self$featureData$V2, cellsData$v1)
      } else super$initialize()
      
      # saves data for reset function
      private$original_data = list(
        counts = self$countData,
        features = self$featureData,
        metadata = self$metaData
      )
      api_test/EMBL-GENBANK-DDBJ_CDS.tsv
      12538
    },
    #' @description
    #' Displays parameters of the `metataxonomics` object via stdout.
    #' @examples
    #' taxa <- metataxonomics$new(metaData = "metadata.tsv",
    #'                            biomData = "biom_with_taxonomy.biom",
    #'                            treeData = "rooted_tree.newick")
    #'
    #' # method 1 to call print function
    #' taxa
    #'
    #' # method 2 to call print function
    #' taxa$print()
    #'
    print = function() {
      if (self$scRNA) {
        cat("## scRNA-class object \n")
        if (length(self$countData) > 0) cat(paste0("## countData:\t[ ", ncol(self$countData), " cells and ", nrow(self$countData), " Genes\t] \n"))
      } else {
        cat("## transcriptomic-class object \n")
        if (length(self$countData) > 0) cat(paste0("## countData:\t[ ", ncol(self$countData), " Samples and ", nrow(self$countData), " Features\t] \n"))
        if (length(self$metaData) > 0) cat(paste0("## metaData:\t[ ", ncol(self$metaData), " Variables and ", nrow(self$metaData), " Samples\t] \n"))
        if (length(self$featureData) > 0) cat(paste0("## taxData:\t[ ", ncol(self$featureData)-1, " Ranks and ", nrow(self$featureData), " Taxa\t] \n"))
      }
    },
    #' @description
    #' Upon creation of a new `metataxonomics` object a small backup of the original data is created.
    #' Since modification of the object is done by reference and duplicates are not made, it is possible to `reset` changes to the class.
    #' The methods from the abstract class `tools` also contain a private method to prevent any changes to the original object. Such cases are ordination, alpha_diversity, differential_feature_expression.
    #' @examples
    #' taxa <- metataxonomics$new(metaData = "metadata.tsv",
    #'                            biomData = "biom_with_taxonomy.biom",
    #'                            treeData = "rooted_tree.newick")
    #'
    #' # Performs modifications
    #' taxa$transform(log2)
    #'
    #' # resets
    #' taxa$reset()
    #'
    #' # An inbuilt reset function prevents unwanted modification to the taxa object.
    #' taxa$rankstat()
    #'
    reset = function() {
      if (self$scRNA) {
        self$countData = private$original_data$counts
      } else {
        self$countData = private$original_data$counts
        self$featureData = private$original_data$features
        self$metaData = private$original_data$metadata
      }
      invisible(self)
    },
  ),
  private = list(
    original_data = list()
  )
)


counts <- Matrix::readMM("./tests/testthat/transcriptomics/input/matrix.mtx.gz")
features <- data.table::fread("./tests/testthat/transcriptomics/input/features.tsv.gz", header=FALSE)
cells <- data.table::fread("./tests/testthat/transcriptomics/input/barcodes.tsv.gz", header=FALSE)



```
